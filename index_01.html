<!DOCTYPE html>
<html lang="en">
  <head>
    <title>kokoro_test</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
    />
    <link type="text/css" rel="stylesheet" href="main.css" />
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"
      integrity="sha512-dLxUelApnYxpLt6K2iomGngnHO83iUvZytA3YjDUCjT0HDOHKXnVYdf3hU4JjM8uEhxf9nD1/ey98U3t2vZ0qQ=="
      crossorigin="anonymous"
    ></script>
    <script src="OrbitControls.js"></script>
    <script src="GLTFLoader.js"></script>
    <script src="RGBELoader.js"></script>
    <script src="RoughnessMipmapper.js"></script>
    <script src="EffectComposer.js"></script>
    <script src="RenderPass.js"></script>
    <script src="UnrealBloomPass.js"></script>
    <script src="LuminosityHighPassShader.js"></script>
    <script src="CopyShader.js"></script>
    <script src="ShaderPass.js"></script>
  </head>

  <body>
    <script type="module">

let camera, scene, renderer, stats;
let composer, mixer, clock;
let mouseX = 0;
let mouseY = 0;
let windowHalfX = window.innerWidth / 2;
let windowHalfY = window.innerHeight / 2;

const params = {
    exposure: 1,
    bloomStrength: 1.5,
    bloomThreshold: 0,
    bloomRadius: 0
};

init();
render();

function init() {
    const container = document.createElement("div");
    document.body.appendChild(container);

    // stats = new Stats();
    // container.appendChild( stats.dom );

    clock = new THREE.Clock();

    renderer = new THREE.WebGLRenderer( { antialias: true } );
    renderer.setPixelRatio( window.devicePixelRatio );
    renderer.setSize( window.innerWidth, window.innerHeight );
    renderer.toneMapping = THREE.ReinhardToneMapping;
    container.appendChild( renderer.domElement );

    const scene = new THREE.Scene();

    camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 100 );
    camera.position.set( - 5, 2.5, - 3.5 );
    scene.add( camera );

    // const controls = new OrbitControls( camera, renderer.domElement );
    // controls.maxPolarAngle = Math.PI * 0.5;
    // controls.minDistance = 1;
    // controls.maxDistance = 10;

    scene.add( new THREE.AmbientLight( 0x404040 ) );

    const pointLight = new THREE.PointLight( 0xffffff, 1 );
    camera.add( pointLight );

    const renderScene = new THREE.RenderPass( scene, camera );

    const bloomPass = new THREE.UnrealBloomPass( new THREE.Vector2( window.innerWidth, window.innerHeight ), 1.5, 0.4, 0.85 );
    bloomPass.threshold = params.bloomThreshold;
    bloomPass.strength = params.bloomStrength;
    bloomPass.radius = params.bloomRadius;

    composer = new THREE.EffectComposer( renderer );
    composer.addPass( renderScene );
    composer.addPass( bloomPass );


    // camera = new THREE.PerspectiveCamera(
    //     45,
    //     window.innerWidth / window.innerHeight,
    //     0.25,
    //     20
    // );
    camera.position.set(-1.8, 0.6, 2.7);

    // renderer = new THREE.WebGLRenderer({ antialias: true });
    // renderer.setPixelRatio(window.devicePixelRatio);
    // renderer.setSize(window.innerWidth, window.innerHeight);
    // renderer.toneMapping = THREE.ACESFilmicToneMapping;
    // renderer.toneMappingExposure = 1;
    // renderer.outputEncoding = THREE.sRGBEncoding;
    // container.appendChild(renderer.domElement);

    const pmremGenerator = new THREE.PMREMGenerator(renderer);
    pmremGenerator.compileEquirectangularShader();

    const roughnessMipmapper = new THREE.RoughnessMipmapper(renderer);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.addEventListener("change", render); // use if there is no animation loop
    controls.minDistance = 2;
    controls.maxDistance = 10;
    controls.target.set(0, 0, -0.2);
    controls.update();

    new THREE.RGBELoader()
        .setDataType(THREE.UnsignedByteType)
        .setPath("textures/equirectangular/")
        .load("circus_arena_2k.hdr", function (texture) {

            const envMap = pmremGenerator.fromEquirectangular(texture).texture;
            //uncomment to see HDRI as background
            // scene.background = envMap;
            scene.environment = envMap;

            texture.dispose();
            pmremGenerator.dispose();

            render();

            // model
            // const loader = new THREE.GLTFLoader().setPath("models/gltf/");
            // loader.load("kokoro_03.gltf", function (gltf) {
            //   gltf.scene.traverse(function (child) {
            //     if (child.isMesh) {
            //       roughnessMipmapper.generateMipmaps(child.material);
            //     }
            //   });

            new GLTFLoader().load( 'models/gltf/PrimaryIonDrive.glb', function ( gltf ) {

                const model = gltf.scene;

                scene.add( model );

                mixer = new THREE.AnimationMixer( model );
                const clip = gltf.animations[ 0 ];
                mixer.clipAction( clip.optimize() ).play();

                animate();

            } );

            scene.add(gltf.scene);

            roughnessMipmapper.dispose();

            render();
        });

    window.addEventListener("resize", onWindowResize);
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();

    renderer.setSize(window.innerWidth, window.innerHeight);

    render();
}

function render() {
renderer.render(scene, camera);
}

    </script>
  </body>
</html>
